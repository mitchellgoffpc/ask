from collections import defaultdict
from dataclasses import dataclass, field
from pathlib import Path
from uuid import UUID, uuid4

from ask.prompts import load_prompt_file, get_relative_path
from ask.models import MODELS_BY_NAME, Message, Text, Image, ToolRequest, ToolResponse, Command, Usage
from ask.tools import ToolCallStatus

COMMAND_CAVEAT_MESSAGE = (
    "Caveat: The messages below were generated by the user while running local commands. "
    "DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.")

@dataclass
class ShellCommand(Command):
    stdout: str = ''
    stderr: str = ''
    status: ToolCallStatus = ToolCallStatus.PENDING

    def messages(self) -> list[Message]:
        if self.status is ToolCallStatus.CANCELLED:
            output = "[Request interrupted by user]"
        else:
            output = f"<bash-stdout>\n{self.stdout}\n</bash-stdout>\n<bash-stderr>\n{self.stderr}\n</bash-stderr>"
        return [
            Message(role='user', content=Text(COMMAND_CAVEAT_MESSAGE)),
            Message(role='user', content=Text(f"<bash-stdin>{self.command}</bash-stdin>")),
            Message(role='user', content=Text(output))]

@dataclass
class SlashCommand(Command):
    output: str = ''
    error: str = ''

    def messages(self) -> list[Message]:
        messages = [
            Message(role='user', content=Text(COMMAND_CAVEAT_MESSAGE)),
            Message(role='user', content=Text(f"<slash-command>{self.command}</slash-command>"))]
        if self.output or not self.error:
            messages.append(Message(role='user', content=Text(f"<slash-command-output>\n{self.output}\n</slash-command-output>")))
        if self.error:
            messages.append(Message(role='user', content=Text(f"<slash-command-error>\n{self.error}\n</slash-command-error>")))
        return messages

@dataclass
class InitCommand(SlashCommand):
    def messages(self) -> list[Message]:
        return [Message(role='user', content=Text(load_prompt_file('init.toml')['prompt']))]

@dataclass
class FilesCommand(SlashCommand):
    file_contents: dict[Path, Text | Image] = field(default_factory=dict)

    def __post_init__(self) -> None:
        self.output = '\n'.join(f'Read {get_relative_path(path)}' for path in self.file_contents.keys())

    def messages(self) -> list[Message]:
        file_list = '\n'.join(f'- {path}' for path in self.file_contents.keys())
        messages = [Message(role='user', content=Text(f"Take a look at these files:\n{file_list}"))]
        for file_path, file_data in self.file_contents.items():
            call_id = str(uuid4())
            tool_args = {'file_path': str(Path(file_path).absolute().as_posix())}
            messages.append(Message(role='assistant', content=ToolRequest(call_id=call_id, tool='Read', arguments=tool_args)))
            messages.append(Message(role='user', content=ToolResponse(call_id=call_id, tool='Read', response=file_data, status=ToolCallStatus.COMPLETED)))
        if self.command:
            messages.append(Message(role='user', content=Text(self.command)))
        return messages

@dataclass
class DocsCommand(Command):
    file_path: Path
    file_contents: str

    def messages(self) -> list[Message]:
        content = load_prompt_file('docs.toml')['prompt'].format(file_path=self.file_path.resolve(), file_contents=self.file_contents)
        return [Message(role='user', content=Text(content))]


# Helper functions

def format_duration(seconds: float) -> str:
    seconds = int(round(seconds))
    minutes, seconds = divmod(seconds, 60)
    hours, minutes = divmod(minutes, 60)
    return (f'{hours}h ' if hours else '') + (f'{minutes}m ' if minutes else '') + f'{seconds}s'

def get_usage_message(messages: dict[UUID, Message], total_duration_api: float, total_duration_wall: float) -> str:
    usages_by_model = defaultdict(list)
    for msg in messages.values():
        if isinstance(msg.content, Usage) and msg.content.model:
            usages_by_model[msg.content.model.name].append(msg.content)

    total_cost = 0.
    rows: list[tuple[str, str]] = []
    for model_name, usages in usages_by_model.items():
        total_in = sum(u.input for u in usages)
        total_out = sum(u.output for u in usages)
        total_cache_w = sum(u.cache_write for u in usages)
        total_cache_r = sum(u.cache_read for u in usages)
        if p := MODELS_BY_NAME[model_name].pricing:
            cost = total_in * p.input + total_cache_w * p.cache_write + total_cache_r * p.cache_read + total_out * p.output
            total_cost += cost
            cost_str = f" (${cost / 1_000_000:,.4f})" if len(usages_by_model) > 1 else ""
        else:
            cost_str = " (no pricing)"
        usage_str = f"{total_in:,} input, {total_out:,} output, {total_cache_r:,} cache read, {total_cache_w:,} cache write" + cost_str
        rows.append((f"    {model_name}", usage_str))

    rows = [
        ("Total cost", f"${total_cost / 1_000_000:,.4f}"),
        ("Total duration (API)", f"{format_duration(total_duration_api)}"),
        ("Total duration (wall)", f"{format_duration(total_duration_wall)}"),
        ("Usage by model", "" if usages_by_model else "(no usage)"),
        *rows
    ]
    max_title_len = max(len(title) + 1 for title, _ in rows)
    return '\n'.join(f"{title + ':':<{max_title_len}}  {value}" for title, value in rows)
