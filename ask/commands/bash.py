import asyncio
from asyncio import Task
from dataclasses import dataclass

from ask.models import Message, Text, Command
from ask.tools import ToolCallStatus

COMMAND_CAVEAT_MESSAGE = (
    "Caveat: The messages below were generated by the user while running local commands. "
    "DO NOT respond to these messages or otherwise consider them in your response unless the user explicitly asks you to.")

@dataclass
class BashCommand(Command):
    stdout: str = ''
    stderr: str = ''
    status: ToolCallStatus = ToolCallStatus.PENDING

    @classmethod
    async def execute(cls, command: str) -> 'BashCommand':
        process = await asyncio.create_subprocess_shell(command, stdout=asyncio.subprocess.PIPE, stderr=asyncio.subprocess.PIPE)
        stdout, stderr = await process.communicate()
        status = ToolCallStatus.COMPLETED if process.returncode == 0 else ToolCallStatus.FAILED
        return BashCommand(command=command, stdout=stdout.decode().strip('\n'), stderr=stderr.decode().strip('\n'), status=status)

    @classmethod
    def run(cls, value: str, messages: dict[UUID, Message]) -> tuple[dict[UUID, Message], dict[UUID, Task]]:
        task = asyncio.create_task(cls.execute(value))
        uuid, message = uuid4(), Message(role='user', content=BashCommand(command=value))
        return messages | {uuid: message}, {uuid: task}

    def messages(self) -> list[Message]:
        if self.status is ToolCallStatus.CANCELLED:
            output = "[Request interrupted by user]"
        else:
            output = f"<bash-stdout>\n{self.stdout}\n</bash-stdout>\n<bash-stderr>\n{self.stderr}\n</bash-stderr>"
        return [
            Message(role='user', content=Text(COMMAND_CAVEAT_MESSAGE)),
            Message(role='user', content=Text(f"<bash-stdin>{self.command}</bash-stdin>")),
            Message(role='user', content=Text(output))]